#include <iostream>

using namespace std;

// for() loop-a е преведено на български 'цикъл', блок на който казваме отколко до колко да 'цикли' ( да върти като пералня :D )
// В скобите на for() цикъла се поставя 'логическо условие', или иначе казано - булев израз, който кара цикъла да се изпълнява, докато израза е true. нещо като if(). толкова, нищо сложно няма :)
// В скобите се пишат и началните условия (преди оценка на лог. условие), преди да започне цикъла, както и динамичен израз, изпълняващ се за всеки цикъл (след всяка оценка на лог. условие). най общо изглежда така:
// for   (    брояча се сетва на 0 ; проверява се условие true/false ; нещо което се изпълнява за всеки цикъл ) { тяло, изпълняващо инструкции докато трае цикъла ; } 
// for   (    int counter = 0;             counter < 10;                         counter++                    ) {    cout << counter << endl ;                      } 
// В горния случай 
// 1. Правим една променлива от тип int counter с начална стойност 0. 
// 2. Проверяваме булев израз (counter < 10) който в крайна сметка връща true или false, дали променливата counter е по-малка от 10
// 3. Увеличаваме стойността на counter с единица. израза counter++ е еквивалентен на counter = counter+1; или също counter += 1; увеличението обаче се случва след изпълнението на кода в скобите {}
// 4. Изпълнява се кода в {} скобите, ако израза (counter < 10) е true.
// 5. Изпълнението отива на точка 2. - проверява се (counter < 10) и т.н. -> 3. -> 4. -> 2. -> 3. -> 4. ... като само int counter = 0; не се повтаря, и така докато (counter < 10) стане false
// Цикъла спира когато counter < 10 върне false. Това евентуално се случва, тъй като увеличаваме стойността на counter в точка 4. при всеки нов цикъл
// В общия смисъл, къде точно се променя стойността, от чиято стойност зависи логическото условие евентуално някога да стане false е без значение, стига това да се случи.


int main (){
  
  for (int counter = 0 ; // точка 1
          counter < 20 ; // точка 2
          counter++ ) // точка 3
  {    cout << (counter+1) * 2 << endl; } // точка 4 
  
  // в общия случай, логиката може да е в пъти по сложна, това което се случва обаче е за всеки цикъл оценяваме логическо условие и цикъла се изпълнява, докато условието е true
  
  
  for (int i = -16 , j = 9 ; // т. 1 инициализираме повече от една променлива 
       ( j+10 >  2*i  ) ||  ( j < -20  ) || i == 0 ; // т. 2 оценяваното условие вече е съставно
       cout << " i do nothing :) " << endl ) // т. 3 на мястото определено за динамична смяна на променливите, от които зависи евентуалният край на цикъла не се случва нищо
  {
    
    // накрая на цикъла все пак, 'променяме' стойностите на i и j , ако искаме край на цикъла някога да се случи     
    cout << "i is: " << i << " j is: " << j << endl;
    
    i++;
    j--;
    
  } // т 4. е всичко в скобите
  
  
  return 0;
}



